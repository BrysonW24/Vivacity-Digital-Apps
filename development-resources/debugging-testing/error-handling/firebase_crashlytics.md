# Firebase Crashlytics Integration Guide

## Overview

Firebase Crashlytics is a lightweight, realtime crash reporter that helps you track, prioritize, and fix stability issues that erode your app quality.

## Setup

### 1. Add Firebase to Your Project

**Prerequisites:**
- Firebase CLI installed
- Firebase project created

```bash
# Install Firebase CLI
npm install -g firebase-tools

# Login to Firebase
firebase login

# Configure Firebase for Flutter
dart pub global activate flutterfire_cli
flutterfire configure
```

Select your Firebase project and platforms (Android, iOS, Web).

### 2. Add Dependencies

```yaml
# pubspec.yaml
dependencies:
  firebase_core: ^2.24.0
  firebase_crashlytics: ^3.4.0

dev_dependencies:
  flutter_test:
    sdk: flutter
```

```bash
flutter pub get
```

### 3. Initialize Firebase Crashlytics

```dart
// lib/main.dart
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'firebase_options.dart';  // Generated by flutterfire configure

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Pass all uncaught Flutter framework errors to Crashlytics
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

  // Pass all uncaught asynchronous errors to Crashlytics
  PlatformDispatcher.instance.onError = (error, stack) {
    FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
    return true;
  };

  runApp(MyApp());
}
```

### 4. Android Configuration

**android/app/build.gradle:**

```gradle
plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'dev.flutter.flutter-gradle-plugin'
    id 'com.google.gms.google-services'  // Add this
    id 'com.google.firebase.crashlytics'  // Add this
}

android {
    // ... existing config

    buildTypes {
        release {
            // Enable Crashlytics in release mode
            firebaseCrashlytics {
                mappingFileUploadEnabled true
            }
        }
    }
}
```

**android/build.gradle:**

```gradle
buildscript {
    dependencies {
        // ... existing dependencies
        classpath 'com.google.gms:google-services:4.4.0'
        classpath 'com.google.firebase:firebase-crashlytics-gradle:2.9.9'
    }
}
```

### 5. iOS Configuration

**ios/Podfile:**

```ruby
target 'Runner' do
  use_frameworks!
  use_modular_headers!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))

  # Add this for Crashlytics
  pod 'Firebase/Crashlytics'
end

# Add this at the end
post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
  end
end
```

```bash
cd ios
pod install
cd ..
```

## Usage

### Recording Errors

#### 1. Automatic Error Reporting

Automatically captures all unhandled errors (already set up in main.dart above).

#### 2. Manual Error Reporting

```dart
import 'package:firebase_crashlytics/firebase_crashlytics.dart';

try {
  // Your code that might throw
  await riskyOperation();
} catch (error, stackTrace) {
  // Report to Crashlytics
  await FirebaseCrashlytics.instance.recordError(
    error,
    stackTrace,
    reason: 'Risky operation failed',
    fatal: false,
  );
}
```

#### 3. Custom Exception Reporting

```dart
// Define custom exception
class PaymentException implements Exception {
  final String message;
  PaymentException(this.message);

  @override
  String toString() => 'PaymentException: $message';
}

// Use it
try {
  processPayment();
} catch (e, stack) {
  if (e is PaymentException) {
    await FirebaseCrashlytics.instance.recordError(
      e,
      stack,
      reason: 'Payment processing failed',
      fatal: false,
    );
  }
}
```

### Adding Custom Logs

```dart
// Add logs for debugging context
Future<void> performOperation() async {
  await FirebaseCrashlytics.instance.log('Starting operation');

  try {
    await FirebaseCrashlytics.instance.log('Step 1: Authenticating');
    await authenticate();

    await FirebaseCrashlytics.instance.log('Step 2: Fetching data');
    final data = await fetchData();

    await FirebaseCrashlytics.instance.log('Step 3: Processing data');
    processData(data);

    await FirebaseCrashlytics.instance.log('Operation completed successfully');
  } catch (e, stack) {
    await FirebaseCrashlytics.instance.log('Operation failed at current step');
    await FirebaseCrashlytics.instance.recordError(e, stack);
  }
}
```

### Setting Custom Keys

Track specific state values:

```dart
Future<void> setUserContext(User user) async {
  await FirebaseCrashlytics.instance.setCustomKey('user_id', user.id);
  await FirebaseCrashlytics.instance.setCustomKey('user_tier', user.tier);
  await FirebaseCrashlytics.instance.setCustomKey('is_premium', user.isPremium);
  await FirebaseCrashlytics.instance.setCustomKey('login_count', user.loginCount);
}

Future<void> setAppState() async {
  await FirebaseCrashlytics.instance.setCustomKey('current_screen', 'HomeScreen');
  await FirebaseCrashlytics.instance.setCustomKey('network_status', 'connected');
  await FirebaseCrashlytics.instance.setCustomKey('app_version', '1.2.3');
}
```

### Setting User Identifier

```dart
Future<void> onUserLogin(String userId) async {
  await FirebaseCrashlytics.instance.setUserIdentifier(userId);
}

Future<void> onUserLogout() async {
  await FirebaseCrashlytics.instance.setUserIdentifier('');
}
```

## Testing Crashlytics

### Force a Test Crash

```dart
// Add a button to trigger test crash
ElevatedButton(
  onPressed: () {
    FirebaseCrashlytics.instance.crash();  // Forces a crash for testing
  },
  child: Text('Test Crash'),
)
```

### Test Without Crashing

```dart
// Test that errors are being sent
Future<void> testCrashlytics() async {
  try {
    throw Exception('Test exception for Crashlytics');
  } catch (e, stack) {
    await FirebaseCrashlytics.instance.recordError(
      e,
      stack,
      reason: 'Test error',
      fatal: false,
    );
  }
}
```

**View in Firebase Console:**
1. Open Firebase Console
2. Navigate to Crashlytics
3. Look for crashes (may take a few minutes to appear)
4. Check in "Non-fatal errors" for test errors

## Advanced Usage

### Conditional Crash Reporting

```dart
import 'package:flutter/foundation.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  // Only enable Crashlytics in release mode
  if (kReleaseMode) {
    FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

    PlatformDispatcher.instance.onError = (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
      return true;
    };
  } else {
    // In debug mode, print to console
    FlutterError.onError = (details) {
      FlutterError.presentError(details);
    };
  }

  runApp(MyApp());
}
```

### Opt-Out for Users

```dart
import 'package:firebase_crashlytics/firebase_crashlytics.dart';

class CrashlyticsService {
  static Future<void> enableCrashlytics(bool enable) async {
    await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(enable);
  }

  static Future<bool> isCrashlyticsEnabled() async {
    return await FirebaseCrashlytics.instance.isCrashlyticsCollectionEnabled();
  }
}

// In settings screen
Switch(
  value: _crashReportingEnabled,
  onChanged: (value) async {
    await CrashlyticsService.enableCrashlytics(value);
    setState(() {
      _crashReportingEnabled = value;
    });
  },
)
```

### Zone-Based Error Handling

```dart
void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  // Capture Flutter framework errors
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

  // Run app in error-capturing zone
  runZonedGuarded<Future<void>>(
    () async {
      runApp(MyApp());
    },
    (error, stack) {
      FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
    },
  );
}
```

## Best Practices

### 1. Add Context Before Errors

```dart
class DataService {
  Future<List<Item>> fetchItems() async {
    await FirebaseCrashlytics.instance.log('fetchItems: Starting');
    await FirebaseCrashlytics.instance.setCustomKey('api_endpoint', '/items');

    try {
      final response = await http.get(url);

      await FirebaseCrashlytics.instance.setCustomKey('response_code', response.statusCode);

      if (response.statusCode == 200) {
        await FirebaseCrashlytics.instance.log('fetchItems: Success');
        return parseItems(response.body);
      } else {
        throw ApiException('Unexpected status code: ${response.statusCode}');
      }
    } catch (e, stack) {
      await FirebaseCrashlytics.instance.log('fetchItems: Failed');
      await FirebaseCrashlytics.instance.recordError(e, stack);
      rethrow;
    }
  }
}
```

### 2. Group Errors by Feature

```dart
class CrashlyticsLogger {
  static Future<void> recordFeatureError(
    String feature,
    dynamic error,
    StackTrace stack, {
    String? action,
    Map<String, dynamic>? extras,
  }) async {
    await FirebaseCrashlytics.instance.setCustomKey('feature', feature);
    if (action != null) {
      await FirebaseCrashlytics.instance.setCustomKey('action', action);
    }

    if (extras != null) {
      for (var entry in extras.entries) {
        await FirebaseCrashlytics.instance.setCustomKey(entry.key, entry.value);
      }
    }

    await FirebaseCrashlytics.instance.recordError(
      error,
      stack,
      reason: '$feature - $action',
    );
  }
}

// Usage
try {
  await saveEntry(entry);
} catch (e, stack) {
  await CrashlyticsLogger.recordFeatureError(
    'Journal',
    e,
    stack,
    action: 'save_entry',
    extras: {'entry_id': entry.id},
  );
}
```

### 3. Don't Report Sensitive Information

```dart
// ❌ BAD: Logging sensitive data
await FirebaseCrashlytics.instance.setCustomKey('password', userPassword);
await FirebaseCrashlytics.instance.setCustomKey('credit_card', cardNumber);
await FirebaseCrashlytics.instance.log('User email: ${user.email}');

// ✅ GOOD: Redact or hash sensitive data
await FirebaseCrashlytics.instance.setCustomKey('user_id_hash', hashUserId(user.id));
await FirebaseCrashlytics.instance.log('Authentication successful');
```

### 4. Set Custom Keys for Debugging

```dart
class AppStateLogger {
  static Future<void> updateState({
    required String screen,
    String? action,
    Map<String, dynamic>? state,
  }) async {
    await FirebaseCrashlytics.instance.setCustomKey('current_screen', screen);
    await FirebaseCrashlytics.instance.setCustomKey('last_action', action ?? 'none');
    await FirebaseCrashlytics.instance.setCustomKey('timestamp', DateTime.now().toIso8601String());

    if (state != null) {
      for (var entry in state.entries) {
        await FirebaseCrashlytics.instance.setCustomKey('state_${entry.key}', entry.value);
      }
    }
  }
}

// Usage in your app
class _HomeScreenState extends State<HomeScreen> {
  @override
  void initState() {
    super.initState();
    AppStateLogger.updateState(screen: 'HomeScreen');
  }

  void _onButtonPressed() {
    AppStateLogger.updateState(
      screen: 'HomeScreen',
      action: 'button_pressed',
      state: {'item_count': _items.length},
    );
  }
}
```

## Viewing Crash Reports

### Firebase Console

1. Open [Firebase Console](https://console.firebase.google.com/)
2. Select your project
3. Navigate to **Crashlytics** in left sidebar
4. View:
   - **Issues**: Grouped crashes
   - **Crash-free users**: Percentage of users not experiencing crashes
   - **Velocity**: Crash trends over time

### Key Metrics to Monitor

- **Crash-free users %**: Should be > 99%
- **Crash rate**: Number of crashes per user session
- **Issue velocity**: New vs recurring issues
- **Impacted users**: Number of users affected

## Troubleshooting

### Crashes Not Appearing

**Check:**
1. Wait 5-10 minutes after crash (processing delay)
2. Ensure Crashlytics is initialized before app runs
3. Check Firebase project configuration
4. Verify `google-services.json` (Android) or `GoogleService-Info.plist` (iOS) is present
5. Run `flutter clean && flutter pub get`

**Force upload:**
```dart
// Manually send pending reports
await FirebaseCrashlytics.instance.sendUnsentReports();
```

### Crashes Only in Release Mode

This is expected behavior. Crashlytics works differently in debug vs release:

```bash
# Test in release mode
flutter run --release

# Or build and install
flutter build apk --release
flutter install
```

### Duplicate Crashes

**Solution:** Use unique identifiers

```dart
await FirebaseCrashlytics.instance.recordError(
  error,
  stack,
  reason: 'Unique context: ${DateTime.now().millisecondsSinceEpoch}',
);
```

## Quick Reference

```dart
// Basic error reporting
FirebaseCrashlytics.instance.recordError(error, stack);

// With context
FirebaseCrashlytics.instance.recordError(error, stack, reason: 'Context', fatal: true);

// Custom logs
FirebaseCrashlytics.instance.log('Message');

// Custom keys
FirebaseCrashlytics.instance.setCustomKey('key', 'value');

// User identifier
FirebaseCrashlytics.instance.setUserIdentifier('user123');

// Enable/disable
FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(true);

// Force crash (testing only)
FirebaseCrashlytics.instance.crash();
```

---

**Resources:**
- [Firebase Crashlytics Documentation](https://firebase.google.com/docs/crashlytics)
- [FlutterFire Crashlytics](https://firebase.flutter.dev/docs/crashlytics/overview/)
- [Firebase Console](https://console.firebase.google.com/)
